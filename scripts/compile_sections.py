import os
import re
import glob
import argparse # Додано для обробки аргументів

def roman_to_int(s):
    """Converts a Roman numeral string (I-X) to an integer."""
    # Basic check for typical document numerals I-IX
    # Extend this mapping if higher numerals are possible
    roman_map = {
        'I': 1, 'II': 2, 'III': 3, 'IV': 4, 'V': 5,
        'VI': 6, 'VII': 7, 'VIII': 8, 'IX': 9, 'X': 10
        # Add XI, XII etc. if needed
    }
    return roman_map.get(s, float('inf')) # Return infinity for unknown numerals to sort them last


def get_section_order(filename):
    """Extracts the Roman numeral from the filename and converts to int for sorting."""
    # Regex to find 'Розділ_' followed by Roman numerals (I to X minimally)
    # and then '_' or '.tex'
    match = re.search(r'Розділ_([IVX]+)[_.]', filename, re.IGNORECASE) # Ignore case just in case
    if match:
        roman = match.group(1).upper() # Convert to uppercase for consistent mapping
        return roman_to_int(roman)
    print(f"Warning: Could not extract Roman numeral from '{filename}'. It might be sorted incorrectly.")
    return float('inf') # Place files without proper naming last

def compile_document(source_dir, output_file):
    """Compiles sections from source_dir into output_file."""
    print(f"\nОбробка директорії: {source_dir}")
    print(f"Вихідний файл: {output_file}")

    if not os.path.isdir(source_dir):
        print(f"Помилка: Директорія '{source_dir}' не знайдена.")
        return False # Повертаємо False при помилці

    # Use glob to find files and handle potential path separator differences
    section_files_pattern = os.path.join(source_dir, 'Розділ_*.tex')
    section_files = glob.glob(section_files_pattern)

    if not section_files:
        print(f"Попередження: У директорії '{source_dir}' не знайдено файлів розділів ('Розділ_*.tex'). Файл '{output_file}' не буде створено або оновлено.")
        # Вирішуємо, чи вважати це помилкою. Наразі - ні.
        # Створимо порожній файл з коментарем?
        try:
            # Переконуємось, що директорія для вихідного файлу існує
            output_dir = os.path.dirname(output_file)
            if output_dir:
                 os.makedirs(output_dir, exist_ok=True)
            with open(output_file, 'w', encoding='utf-8') as outfile:
                outfile.write(f"% No sections found in {source_dir}\n")
                outfile.write("% Automatically generated by compile_sections.py\n")
            print(f"Створено порожній файл '{output_file}', оскільки розділи не знайдено.")
            return True # Повертаємо True, оскільки порожній файл створено
        except IOError as e:
            print(f"Помилка запису порожнього файлу '{output_file}': {e}")
            return False

    # Sort files based on the Roman numeral extracted
    section_files.sort(key=lambda f: get_section_order(os.path.basename(f)))

    print(f"Знайдено та відсортовано розділи для '{source_dir}':")
    sorted_basenames = [os.path.basename(f) for f in section_files]
    print(f"  Порядок: {', '.join(sorted_basenames)}")

    try:
        # Переконуємось, що директорія для вихідного файлу існує
        output_dir = os.path.dirname(output_file)
        if output_dir:
             os.makedirs(output_dir, exist_ok=True)

        with open(output_file, 'w', encoding='utf-8') as outfile:
            outfile.write(f"% Compiled content from {source_dir}\n")
            outfile.write("% Automatically generated by compile_sections.py\n\n")
            for section_file_path in section_files:
                section_filename = os.path.basename(section_file_path)
                outfile.write(f"% --- Start of {section_filename} ---\n")
                try:
                    with open(section_file_path, 'r', encoding='utf-8') as infile:
                        content = infile.read()
                        if not content.endswith('\n'):
                            content += '\n'
                        outfile.write(content)
                    outfile.write(f"% --- End of {section_filename} ---\n\n")
                except IOError as e:
                    print(f"Помилка читання файлу '{section_file_path}': {e}")
                    outfile.write(f"% !!! Error reading {section_filename} !!!\n\n")
                    # Можливо, варто перервати процес тут або повернути False?
                    # Залишимо поки так, щоб спробувати обробити інші файли.
                except UnicodeDecodeError as e:
                    print(f"Помилка декодування файлу '{section_file_path}': {e}. Перевірте кодування файлу (має бути UTF-8).")
                    outfile.write(f"% !!! Encoding error reading {section_filename} (Expected UTF-8) !!!\n\n")

        print(f"Успішно скомпільовано розділи з '{source_dir}' у файл '{output_file}'")
        return True # Успішне завершення
    except IOError as e:
        print(f"Помилка запису у файл '{output_file}': {e}")
        return False # Помилка запису

# --- Main execution --- 
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Компілює LaTeX розділи з вказаної директорії в один файл.')
    parser.add_argument('-s', '--source-dir', required=True, help='Директорія з файлами розділів (Розділ_*.tex).')
    parser.add_argument('-o', '--output-file', required=True, help='Шлях до вихідного скомпільованого .tex файлу.')

    args = parser.parse_args()

    print("Запуск компіляції розділів...")
    success = compile_document(args.source_dir, args.output_file)

    if success:
        print("\nКомпіляція одного документа завершена успішно.")
    else:
        print("\nКомпіляція одного документа завершена з помилками.")
        # exit(1) # Можна додати вихід з кодом помилки, якщо потрібно для Makefile 